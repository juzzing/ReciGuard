import pandas as pd
import numpy as np
from fastapi import FastAPI
from pydantic import BaseModel
from sklearn.metrics.pairwise import cosine_similarity

# FastAPI 인스턴스 생성
app = FastAPI()

# 데이터 파일 로드 (사용자가 제공한 경로로 읽기)
Recipe = pd.read_excel(r'C:\Users\박민주\Desktop\data\Recipe.xlsx')
User_Cuisine = pd.read_excel(r'C:\Users\박민주\Desktop\data\User_Cuisine.xlsx')
User_FoodType = pd.read_excel(r'C:\Users\박민주\Desktop\data\User_FoodType.xlsx')
User_CookingStyle = pd.read_excel(r'C:\Users\박민주\Desktop\data\User_CookingStyle.xlsx')
User_Scrap = pd.read_excel(r'C:\Users\박민주\Desktop\data\User_Scrap.xlsx')

from gensim.models import Word2Vec
import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.preprocessing import MinMaxScaler
from datetime import datetime

WEIGHT_CUISINE = 0.5       # 음식 종류 가중치
WEIGHT_FOODTYPE = 0.3      # 음식 유형 가중치
WEIGHT_COOKINGSTYLE = 0.2  # 조리 방법 가중치

TIME_WEIGHT = 0.3          # 최신 레시피 반영 비율

HYBRID_WEIGHT = 0.7        # 콘텐츠 기반 추천 비율

# 레시피 임베딩 생성 함수
def embed_recipe(features, word2vec_model, embedding_dim=8):
    feature_list = str(features).split()
    embeddings = [word2vec_model.wv[feature] for feature in feature_list if feature in word2vec_model.wv]
    return np.mean(embeddings, axis=0) if embeddings else np.zeros(embedding_dim)

# 콘텐츠 기반 필터링 (Word2Vec 기반)
def content_based_filtering_embedding(user_id, User_Cuisine, User_FoodType, User_CookingStyle, Recipe,
                                       weight_cuisine=WEIGHT_CUISINE, weight_foodtype=WEIGHT_FOODTYPE, weight_cookingstyle=WEIGHT_COOKINGSTYLE):
    # 레시피 데이터 전처리
    Recipe['combined_features'] = Recipe['cuisine'].fillna('') + ' ' + Recipe['food_type'].fillna('') + ' ' + Recipe['cooking_style'].fillna('')
    all_features = Recipe['combined_features'].apply(lambda x: x.split()).tolist()

    # Word2Vec 학습
    word2vec_model = Word2Vec(sentences=all_features, vector_size=8, window=5, min_count=1, workers=4)

    # 사용자 선호 정보 추출
    user_cuisine = User_Cuisine[User_Cuisine['user_id'] == user_id]['cuisine'].fillna('').astype(str).str.split(',').tolist()[0]
    user_foodtype = User_FoodType[User_FoodType['user_id'] == user_id]['food_type'].fillna('').astype(str).str.split(',').tolist()[0]
    user_cookingstyle = User_CookingStyle[User_CookingStyle['user_id'] == user_id]['cooking_style'].fillna('').astype(str).str.split(',').tolist()[0]

    # 사용자 프로필 임베딩
    cuisine_embeddings = [word2vec_model.wv[feature] for feature in user_cuisine if feature in word2vec_model.wv]
    foodtype_embeddings = [word2vec_model.wv[feature] for feature in user_foodtype if feature in word2vec_model.wv]
    cookingstyle_embeddings = [word2vec_model.wv[feature] for feature in user_cookingstyle if feature in word2vec_model.wv]

    cuisine_vector = np.mean(cuisine_embeddings, axis=0) if cuisine_embeddings else np.zeros(8)
    foodtype_vector = np.mean(foodtype_embeddings, axis=0) if foodtype_embeddings else np.zeros(8)
    cookingstyle_vector = np.mean(cookingstyle_embeddings, axis=0) if cookingstyle_embeddings else np.zeros(8)

    user_profile_embedding = (weight_cuisine * cuisine_vector +
                              weight_foodtype * foodtype_vector +
                              weight_cookingstyle * cookingstyle_vector)

    # 레시피 임베딩 및 유사도 계산
    recipe_embeddings = Recipe['combined_features'].apply(lambda x: embed_recipe(x, word2vec_model))
    recipe_embeddings_matrix = np.vstack(recipe_embeddings.values)
    similarities = cosine_similarity([user_profile_embedding], recipe_embeddings_matrix)[0]
    Recipe['content_score'] = similarities

    # 콘텐츠 점수 정규화
    scaler = MinMaxScaler()
    Recipe['content_score'] = scaler.fit_transform(Recipe[['content_score']])

    # 추천 결과 반환
    return Recipe[['recipe_id', 'content_score']].sort_values(by='content_score', ascending=False)

# 자카드 유사도 계산
def calculate_jaccard_similarity(user_profile, other_cuisine, other_foodtype, other_cookingstyle):
    other_profile = set(other_cuisine + other_foodtype + other_cookingstyle)
    return len(user_profile & other_profile) / len(user_profile | other_profile)

# 사용자 기반 협업 필터링
def user_based_collaborative_filtering(user_id, User_Cuisine, User_FoodType, User_CookingStyle, User_Scrap, Recipe, time_weight=0.3):

    # 사용자 선호 정보 가져오기
    user_cuisine = User_Cuisine[User_Cuisine['user_id'] == user_id]['cuisine'].fillna('').astype(str).str.split(',').tolist()[0]
    user_foodtype = User_FoodType[User_FoodType['user_id'] == user_id]['food_type'].fillna('').astype(str).str.split(',').tolist()[0]
    user_cookingstyle = User_CookingStyle[User_CookingStyle['user_id'] == user_id]['cooking_style'].fillna('').astype(str).str.split(',').tolist()[0]

    user_profile = set(user_cuisine + user_foodtype + user_cookingstyle)

    # 다른 사용자와 유사도 계산
    other_users = User_Cuisine[User_Cuisine['user_id'] != user_id]['user_id'].unique()
    user_similarities = {
        other_user: calculate_jaccard_similarity(
            user_profile,
            User_Cuisine[User_Cuisine['user_id'] == other_user]['cuisine'].fillna('').astype(str).str.split(',').tolist()[0],
            User_FoodType[User_FoodType['user_id'] == other_user]['food_type'].fillna('').astype(str).str.split(',').tolist()[0],
            User_CookingStyle[User_CookingStyle['user_id'] == other_user]['cooking_style'].fillna('').astype(str).str.split(',').tolist()[0]
        ) for other_user in other_users
    }

    # 유사도가 높은 사용자 추출
    similar_users = sorted(user_similarities.items(), key=lambda x: x[1], reverse=True)
    similar_user_ids = [user for user, sim in similar_users if sim > 0]
    similar_scraps = User_Scrap[User_Scrap['user_id'].isin(similar_user_ids)].copy()

    # 유사도 점수 반영
    similarity_scores = dict(similar_users)
    similar_scraps['similarity_score'] = similar_scraps['user_id'].map(similarity_scores)

    # 사용자가 스크랩하지 않은 레시피 추천
    user_scrap_recipes = User_Scrap[User_Scrap['user_id'] == user_id]['recipe_id'].tolist()
    recommended_recipes = similar_scraps[~similar_scraps['recipe_id'].isin(user_scrap_recipes)].copy()
    recommended_recipes = recommended_recipes.merge(Recipe, on='recipe_id')

    # 최신성 반영
    current_date = datetime.now()
    recommended_recipes['created_at'] = pd.to_datetime(recommended_recipes['created_at'])
    recommended_recipes['days_since_created'] = (current_date - recommended_recipes['created_at']).dt.days
    recommended_recipes['time_score'] = np.exp(-recommended_recipes['days_since_created'] / 7) # 7일 기준

    # 최종 점수 계산
    recommended_recipes['collab_score'] = (1 - time_weight) * recommended_recipes['similarity_score'] + time_weight * recommended_recipes['time_score']

    # 점수 정규화
    scaler = MinMaxScaler()
    recommended_recipes['collab_score'] = scaler.fit_transform(recommended_recipes[['collab_score']])

    # 추천 결과 반환
    return recommended_recipes[['recipe_id', 'collab_score']].drop_duplicates().sort_values(by='collab_score', ascending=False).reset_index(drop=True)

# 하이브리드 추천 함수 (콘텐츠 + 협업 필터링)
def hybrid_recommendation(user_id, User_Cuisine, User_FoodType, User_CookingStyle, User_Scrap, Recipe, hybrid_weight=HYBRID_WEIGHT):

    # 콘텐츠 기반 추천 점수 계산
    content_scores = content_based_filtering_embedding(user_id, User_Cuisine, User_FoodType, User_CookingStyle, Recipe)

    # 협업 필터링 추천 점수 계산
    collab_scores = user_based_collaborative_filtering(user_id, User_Cuisine, User_FoodType, User_CookingStyle, User_Scrap, Recipe)

    # 두 점수 병합
    combined_scores = content_scores.merge(collab_scores, on='recipe_id', how='outer')
    combined_scores['final_score'] = (combined_scores['content_score'] * hybrid_weight +
                                       combined_scores['collab_score'] * (1 - hybrid_weight))
    combined_scores = combined_scores.drop_duplicates(subset='recipe_id')
    combined_scores_sorted = combined_scores.sort_values(by='final_score', ascending=False).reset_index(drop=True)

    # 최상위 레시피 추천
    return combined_scores_sorted.iloc[0]['recipe_id']

# API를 위한 Pydantic 모델 정의
class UserRequest(BaseModel):
    user_id: int

# API 엔드포인트 정의
@app.post("/recommend")
async def get_recommendation(request: UserRequest):
    user_id = request.user_id
    recipe_id = hybrid_recommendation(user_id, User_Cuisine, User_FoodType, User_CookingStyle, User_Scrap, Recipe)
    return {"user_id": user_id, "recommended_recipe_id": recipe_id}
